API Builder: Architecture and Implementation Review

ðŸ“˜ Table of Contents

Chapter	Title	Description
1	Introduction	Overview of the goal and what we built
2	Project Initialization	Setting up the architecture and baseline tools
3	CLI Token Auth System	Handling login, bearer tokens, and environment variables
4	OpenAPI Parsing & Endpoint Generation	Automating SDK wrapper generation from OpenAPI JSON
5	CLI Design: Modular Commands	Separating system logic from API endpoint logic
6	Query Engine with Dependency Resolution	Smart CLI to resolve endpoint dependencies automatically
7	Pagination and Data Fetching	Fetching across pages with defaults and loops
8	Results and Next Steps	Summary and where to go from here


â¸»

Chapter 1: Introduction

The goal of this project is to build a CLI-driven tool that acts as a local API assistant:
	â€¢	Parses any OpenAPI file
	â€¢	Generates usable Python functions (endpoint wrappers)
	â€¢	Prompts the user through an intelligent CLI to navigate endpoints, handle required arguments, and output responses
	â€¢	Minimizes boilerplate, maximizes reuse

The development was done using CursorAI as a programming partner and Copilot, with the goal to have this tool also usable and expandable by non-expert developers.

â¸»

Chapter 2: Project Initialization

Purpose

Establish the baseline architecture with a clean, testable, and automated development environment.

Tasks
	â€¢	Created api-central/ folder structure
	â€¢	Defined in pyproject.toml:
	â€¢	poetry for dependency management
	â€¢	typer, pydantic-settings, openapi-python-client, etc.
	â€¢	Set up .env.example and CI/CD with lint/test/type check

Obstacles
	â€¢	Initial TOML file had syntax errors and outdated dependency formats
	â€¢	Poetry install required pinning to Python 3.12 and correcting deprecated config sections

Outcome
	â€¢	Successfully launched with lintable, type-safe dev environment
	â€¢	Cursor-ready scaffolding for future scripts

â¸»

Chapter 3: CLI Token Auth System

Purpose

Handle authentication via username/password â†’ bearer token, and securely store it for reuse.

Features
	â€¢	CLI auth get-token command
	â€¢	Uses requests.post() to get bearer token
	â€¢	Saves token to ~/.tattle-cli/credentials.json
	â€¢	All API calls use get_saved_token() helper

Obstacles
	â€¢	Ensuring .env was read before auth command ran
	â€¢	Resolving BaseSettings import after pydantic v2 migration

Outcome
	â€¢	Token is successfully saved and reused
	â€¢	Auth CLI flow complete

â¸»

Chapter 4: OpenAPI Parsing & Endpoint Generation

Purpose

Auto-generate Python wrapper functions for each endpoint in the OpenAPI file.

Features
	â€¢	Script: scripts/generate_endpoints.py
	â€¢	Parses openai.json
	â€¢	Sorts endpoints by base path (e.g. merchants.py, locations.py)
	â€¢	Function names generated as get_path_variable_safe_names()
	â€¢	Includes summary as a docstring for future UI use

Obstacles
	â€¢	Duplicated functions in same file caused syntax crashes (e.g. duplicate def merchants())
	â€¢	Missing parentheses, unclosed code blocks

Fixes
	â€¢	De-duplicated functions by keying per file + function name
	â€¢	Cleaned variable interpolation

Outcome
	â€¢	All valid GET endpoints converted to Python function wrappers
	â€¢	Output files clean and syntax-safe

â¸»

Chapter 5: CLI Design: Modular Commands

Purpose

Separate CLI interface logic from API wrappers.

Features
	â€¢	CLI commands in cli/commands/
	â€¢	API wrappers in cli/endpoints/gettattle/
	â€¢	main.py wires CLI commands to Typer groups

Obstacles
	â€¢	Originally tried to write CLI command logic directly in wrappers (mixed concerns)
	â€¢	Cursor file routing required strict separation

Outcome
	â€¢	All CLI commands are just interface prompts
	â€¢	API calls only happen in wrappers

â¸»

Chapter 6: Query Engine with Dependency Resolution

Purpose

Allow user to pick any endpoint and have CLI smartly resolve all required parameters.

Features
	â€¢	Command: system query-api
	â€¢	Parses OpenAPI spec
	â€¢	Lists endpoints sorted by required param count
	â€¢	Checks context for each required param
	â€¢	If missing, identifies endpoint that returns that param and auto-calls it
	â€¢	Prompts user to pick returned values (e.g. merchantId)
	â€¢	Stores values in ~/.tattle-cli/context.json

Obstacles
	â€¢	Missing or broken token caused 401s
	â€¢	Some endpoints had malformed Python wrappers due to bad generation

Fixes
	â€¢	Regenerated wrappers safely
	â€¢	Added logic to skip or auto-default Page and PageSize

Outcome
	â€¢	Able to query /locations â†’ waterfall call /merchants to get merchantId
	â€¢	Smart fallback: stored â†’ resolved â†’ prompted

â¸»

Chapter 7: Pagination and Data Fetching

Purpose

Support auto-fetching full datasets across paginated endpoints.

Features
	â€¢	Defaults:
	â€¢	Page = 1
	â€¢	PageSize = 50
	â€¢	Looks for hasNextPage in response
	â€¢	Repeats call until hasNextPage = false
	â€¢	Aggregates all data[] across pages

Obstacles
	â€¢	None â€” logic layered cleanly on top of param resolution

Outcome
	â€¢	Full /locations dataset retrieved in a single CLI run
	â€¢	Works with any paginated endpoint

â¸»

Chapter 8: Results and Next Steps

Achievements
	â€¢	Tokenized, secure CLI flow
	â€¢	Smart, auto-generated endpoint wrappers
	â€¢	Fully resolved parameter dependencies
	â€¢	Paginated data retrieval
	â€¢	Clean modular codebase (CLI â¬„ endpoint â¬„ context)

Next Priorities
	â€¢	Interactive field filtering (choose which keys from the JSON to output)
	â€¢	Export CLI output to CSV/JSON
	â€¢	Detect nested dependencies across paths (e.g. location â†’ merchant â†’ group)
	â€¢	Improve auto-discovery of which endpoints return which fields
	â€¢	Add POST endpoint support
	â€¢	Group endpoints in CLI via tag or resource

â¸»

Final Reflection

What Worked Well
	â€¢	CursorAI was an excellent partner for iterative prompt-driven dev
	â€¢	The modular breakdown between endpoint, CLI, and context worked cleanly
	â€¢	Error messages (401, syntax) were quickly actionable

What Could Improve
	â€¢	Initial endpoint generator lacked duplication protection
	â€¢	Parameter-to-endpoint resolver would benefit from a search index of fields â†’ paths
	â€¢	Not all endpoints had examples in OpenAPI â€” consider adding mock data for better CLI prompt options

Suggested Improvement
	â€¢	Add a metadata.json registry that maps known parameters (e.g. merchantId) to safe endpoints (e.g. /merchants) to skip inference

â¸»

End of Report. Resume with: poetry run python cli/main.py system query-api